-- -
Cheatsheet for gdb. I should eventually memorize this stuff, but while I get there I want to have a sheet of stuff to reference.
#### setup gdb in intel syntax
by default, gdb will show the output in AT&T syntax (for some unholy reason), so this is how you can change that:
```bash
# open config file, create if not on the filesystem
vim ~/.gdbinit

# set to intel syntax in the .gdbinit file.
set disassembly-flavor intel
```
#### Load and Run programs in gdb
```bash
# load program w/ gdb
gdb <path>
gdb ./a.out

# run program
# if you are in the middle of an execution and run this again, it will ask if you want to start the program over. Breakpoints stay where you set them. 
run
r

# run program w/ argument(s)
run <arg> <arg> <arg>
r <arg>
```
#### Breakpoints
```bash 
# show set breakpoints w/ their numbers
 info break

# set a breakpoint
# note: if you set a breakpoint on a function, you need to dereference it for this to work. 
# long
breakpoint *<function name>
breakpoint <memory address>

# shorthand
b *<function name>
b <memory address> 

# delete breakpoints
del breakpoint <num>
del breakpoint 1 # deletes the first breakpoint you set

# continue to next breakpoint or until program terminates
continue
c

# set breakpoint to offset/relative to a function
# this is less annoying than setting a breakpoint to a memory location bc in modern programs, the memory address will be randomized so a breakpoint set to a memory location may likely not be the same between executions. 
# Note: offsets are shown if you disassemble the function or show instructions or whatever.
b *<function> + <offset>
b *main + 10
```
#### Stepping
Different ways of stepping instructions/functions
```bash
si # step instruction, if function, step into
ni # step instruction, if function, step over
finish # step out of function
```
#### Show functions
use to orient yourself, think of what you see in a static disassembler
```bash
# disassemble an entire function, examine the assembly code of an entire function.
disassemble <function>
disass <function> 
disass main
```
#### Print specific values
```bash
# Show data in all registers
info register 
info reg

# show data in specific register
print $<register>
print $rax
p $rax

# you can also print in a specified format
p/d $rsp # print signed integer value at stack
p/a $rsp # print address at rsp

# Examine values
# lets you output data in variables but also specify the format.
x/i $rip # examine the instruction at location pointed to by rip
x/10i $rip # examine instruction + 10 instructions at location in rip

# Examine the Stack
# examine 4 giant words as hex values on the stack
# g: giant words
# x: hex values
x/4gx $rsp

# four signed integer values
x/4d $rsp

# four unsigned numbers
x/4u $rsp

# 4 addresses
x/4a $rsp
```
#### Configure data displayed on each step
```bash
# tell gdb what to display each time it steps
# can format this as with examine or print
# following will print out the address held in rip with each step
display/a $rip

# show 4 instructions at each step
display/4i $rip
```
#### Set user defined variables
You can store values in variables ;and I'm sure manipulate registers and such while debugging 
```bash
set $my_variable = $rdi
set $my_var = *(long *) $rsp # stores balue as a long

# set register to value you define, you will need to format the value
set *(long *) $rsp = 0x1337

# change execution place to an offset
# will likely break your shit
set $rip = *main + 73
```
#### Scripts
You can run scripts in GDB, you need to setup a script file like: `my_script.gdb`, then put in your gdb commands into it. Then just run:
```bash
gdb -x my_script.gdb ./a.out
```
Generally, you can just put commands line by line in the script and get it to run, but you can do a function/loop type thing:
```bash
# inside my_script.gdb
b *main
# every time the above breakpoint is hit, the code between "coommands" and "end" will be run
commands
	silent # supresses output for this step
	p $rip
	continue
end

run robert
continue
```
#### Plugins
setup plugins, such as GEF
```bash
# gef shows more verbose output, it will dump out the register values, the stack, and a small disassembly of the area you currently are at each step. Will also put out color coded output. Provides other contextual information such as providing the string values that correspond to the bytes in a register or on the stack. 

# also outputs the flag values

# color coding of output also provides context, like purple output being stack values. Yellow for strings, green is heap values, etc. 

# inside the .gdbinit file
source /opt/gef/gef.py
```