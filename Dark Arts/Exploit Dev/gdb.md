-- -
Cheatsheet for gdb. I should eventually memorize this stuff, but while I get there I want to have a sheet of stuff to reference.
#### Load and Run programs in gdb
```bash
# load program w/ gdb
gdb <path>
gdb ./a.out

# run program
# if you are in the middle of an execution and run this again, it will ask if you want to start the program over. Breakpoints stay where you set them. 
run
r

# run program w/ argument(s)
run <arg> <arg> <arg>
r <arg>
```
#### Breakpoints
```bash 
# show set breakpoints w/ their numbers
 info break

# set a breakpoint
# note: if you set a breakpoint on a function, you need to dereference it for this to work. 
# long
breakpoint *<function name>
breakpoint <memory address>

# shorthand
b *<function name>
b <memory address> 

# delete breakpoints
del breakpoint <num>
del breakpoint 1 # deletes the first breakpoint you set

# continue to next breakpoint or until program terminates
continue
c

# set breakpoint to offset/relative to a function
# this is less annoying than setting a breakpoint to a memory location bc in modern programs, the memory address will be randomized so a breakpoint set to a memory location may likely not be the same between executions. 
# Note: offsets are shown if you disassemble the function or show instructions or whatever.
b *<function> + <offset>
b *main + 10
```
#### Stepping
Different ways of stepping instructions/functions
```bash
si # step instruction, if function, step into
ni # step instruction, if function, step over
finish # step out of function
```
#### Show functions
use to orient yourself, think of what you see in a static disassembler
```bash
# disassemble an entire function, examine the assembly code of an entire function.
disassemble <function>
disass <function> 
disass main
```
#### Print specific values
```bash
# Show data in all registers
info register 
info reg

# show data in specific register
print $<register>
print $rax
p $rax

# you can also print in a specified format
p/d $rsp # print signed integer value at stack
p/a $rsp # print address at rsp

# Examine values
# lets you output data in variables but also specify the format.
x/i $rip # examine the instruction at location pointed to by rip
x/10i $rip # examine instruction + 10 instructions at location in rip

# Examine the Stack
# examine 4 giant words as hex values on the stack
# g: giant words
# x: hex values
x/4gx $rsp

# four signed integer values
x/4d $rsp

# four unsigned numbers
x/4u $rsp

# 4 addresses
x/4a $rsp
```
#### Configure data displayed on each step
```bash
# tell gdb what to display each time it steps
# can format this as with examine or print
# following will print out the address held in rip with each step
display/a $rip

# show 4 instructions at each step
display/4i $rip
```
#### Set user defined variables
You can store values in variables ;and I'm sure manipulate registers and such while debugging 
```bash
set $my_variable = $rdi
set $my_var = *(long *) $rsp # stores balue as a long

# set register to value you define, you will need to format the value
set *(long *) $rsp = 0x1337

# change execution place to an offset
# will likely break your shit
set $rip = *main + 73
```
#### Scripts
You can run scripts in GDB, you need to setup a script file like: `my_script.gdb`, then put in your gdb commands into it. Then just run:
```bash
gdb -x my_script.gdb ./a.out
```